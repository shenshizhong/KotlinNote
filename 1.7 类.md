
1、关于接口
```
1、申明一个简单的接口
interface Clickable{
       fun click()
       fun showOff() = println("I'm clickable!")   //可以有默认实现
       }
       
2、实现一个接口
class Button : Clickable{
       override fun click() = println("I was clicked!")
}
```

2、申明一个open类
```
open class RichButton : Clickable{
       fun disable(){}               //默认是final的
       open fun animate(){}          //可以被重写
       override fun click(){...}     //重写了一个open函数，本身还可以被重写
       }
       
禁止重写
open class RichButton : Clickable{
      final override fun click(){...}   //禁止重写
       }
```
3、申明一个抽象类
```
abstract class Animated{            //不能创建实例
       abstract fun animate()       //可被重写
       open fun stopAnimating(){}   //添加open，可以被重写
       fun animateTwice(){}         //普通方法，默认不能被重写
}

```
4、内部类与嵌套类
```
嵌套类不能访问外部类的实例

嵌套类
class Button : View{
        override fun getCurrentState(): State = ButtonState()
        override fun restoreState(state: State){...}
        class ButtonState : State{}      //默认不引用外部类
}

内部类
class Outer{
        inner class Inner{
                fun getOuterReference(): Outer = this@Outer
        }

}

```
注意点：扩展函数不能访问它的private 和protected 成员

5、写一个密封类
```
列出所有可能嵌套类
sealed class Expr{
         class Num(val value: Int): Expr()
         class Sum(val left: Expr, val right: Expr): Expr()
}

fun eval(e: Expr): Int = 
         when(e){
              is Expr.Num -> e.value
              is Expr.Sum -> eval(e.right) + eval(e.left)
         }
```
6、使用主构造方法，初始化父类
```
初始化一个类

原始写法：
class User constructor(_nickname: String){ //包含初始化块，可以有很多个初始化块
   val nickname: String
   
   init{
      nickname = _nickname
   }
}

最简单的写法：
class User(val nickname: String)    //使用了主构造方法


初始化一个父类
open class User(val nickname: String){...}
class TwitterUser(nickname: String): User(nickname){...}  //主构造方法初始父类

open class Button              //生成一个不带任何参数的构造方法
class RadioButton: Button()    //代表显示调用父类构造方法

class Secretive private constructor()   //声明一个带 私有的构造方法 的类

```
7、使用从构造方法，初始化父类
```
open class View{  //只有从构造方法
    constructor(ctx: Context){...}
    constructor(ctx: Context, attr: AttributeSet){...}
}

class MyButton : View{
    constructor(ctx: Context) : super(ctx){...}    //调用父类从构造方法
    constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr){...}
}


class MyButton : View{
    constructor(ctx: Context) : this(ctx, MY_STYLE){...} //委托给下面的从构造方法
    constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr){...}
}
```